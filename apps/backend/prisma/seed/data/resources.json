[
  {
    "title": "Big-O Cheat Sheet",
    "content": "# Big-O Cheat Sheet\n\nQuick reference for time and space complexity of common data structures and algorithms.\n\n## Array Operations\n- Access: O(1)\n- Insert/Delete: O(n)\n\n## Hash Map Operations\n- Average Insert/Delete/Lookup: O(1)\n- Worst-case: O(n) when collisions degrade\n\n## Sorting Algorithms\n| Algorithm | Average | Worst | Space | Notes |\n| --- | --- | --- | --- | --- |\n| Merge Sort | O(n log n) | O(n log n) | O(n) | Stable |\n| Quick Sort | O(n log n) | O(n^2) | O(log n) | In-place |\n| Heap Sort | O(n log n) | O(n log n) | O(1) | In-place |\n\n## Graph Traversals\n- BFS: O(V + E)\n- DFS: O(V + E)\n\nKeep this sheet nearby during interviews!",
    "type": "REFERENCE",
    "category": "Algorithms",
    "difficulty": "MEDIUM"
  },
  {
    "title": "Practical Guide to SQL Joins",
    "content": "# SQL Joins in Practice\n\n## INNER JOIN\nReturns rows with matching keys in both tables.\n\n```sql\nSELECT u.id, o.total\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n```\n\n## LEFT JOIN\nKeep all rows from left table, null for missing right rows.\n\n## CROSS APPLY\nGreat for JSON array expansion in Postgres/SQL Server.\n\nUse EXPLAIN ANALYZE to verify performance and add indexes on join keys.",
    "type": "GUIDE",
    "category": "Databases",
    "difficulty": "MEDIUM"
  },
  {
    "title": "Working with Async/Await in JavaScript",
    "content": "# Async/Await Essentials\n\n- Wrap asynchronous operations in promises.\n- Use try/catch for error handling.\n\n```ts\nexport async function fetchUser(id: string) {\n  try {\n    const res = await fetch(`/api/users/${id}`);\n    if (!res.ok) throw new Error('Network error');\n    return await res.json();\n  } catch (error) {\n    console.error(error);\n    throw error;\n  }\n}\n```\n\nCombine with `Promise.all` for parallel calls and `AbortController` for cancellation.",
    "type": "TUTORIAL",
    "category": "JavaScript",
    "difficulty": "LOW"
  },
  {
    "title": "Rust Ownership Crash Course",
    "content": "# Rust Ownership Crash Course\n\n1. Each value has a single owner.\n2. Ownership moves on assignment or passing into functions.\n3. Borrow with references (`&T`, `&mut T`) to avoid moves.\n\n```rust\nfn main() {\n    let s = String::from(\"hi\");\n    print_ref(&s); // borrow\n    // print_move(s); // would move and invalidate\n}\n```\n\nMastering ownership unlocks fearless concurrency.",
    "type": "GUIDE",
    "category": "Rust",
    "difficulty": "HIGH"
  },
  {
    "title": "Designing a Rate Limiter",
    "content": "# Designing a Token Bucket Rate Limiter\n\nComponents:\n1. Bucket capacity\n2. Refill rate\n3. Atomic counter or distributed store\n\nPseudo-code:\n```python\ndef allow_request(user_id):\n    bucket = redis.get(user_id) or Bucket(capacity, tokens=capacity)\n    bucket.refill(now)\n    if bucket.tokens > 0:\n        bucket.tokens -= 1\n        redis.set(user_id, bucket)\n        return True\n    return False\n```\n\nDiscuss trade-offs between in-memory, Redis, and sliding window approaches.",
    "type": "TUTORIAL",
    "category": "System Design",
    "difficulty": "HIGH"
  }
]
